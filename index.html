<!doctype html>
<html>
  <head>
  <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Presentation for Tesla Onsite</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section>
          <h2>
              <span class="fragment fade-in-then-semi-out">Motion planning for</span>
              <span class="fragment fade-in-then-semi-out">2D</span>
              <span class="fragment fade-in-then-semi-out">stick-figure</span>
              <span class="fragment fade-in-then-semi-out">climbing agents</span>
          </h2>
          <p>
            <small>Created by <a href="https://github.com/buggedbit/">Yashasvi Sriram Patkuri</a></small>
          </p>
        </section>

        <section>TODO: my intro, interests hobbies, motion planning, particle systems, physics, sixth sense, escape room, drive, project demo clips, climbing clips</section>

        <section>
          <section>
            <h2>the problem</h2>
          </section>
          <section>
            <h2>the world</h2>
            <ul>
            <li class="fragment">2D wall</li>
            <li class="fragment">points representing holds</li>
            <li class="fragment">has a start hold and a finish hold</li>
            </ul>
            <img class="fragment" width="500px" src="media/images/world.png">
          </section>
          <section>
            <h2>chain agent</h2>
            <ul>
            <li class="fragment">line segments connected via revolute joints</li>
            <li class="fragment">can be chained</li>
            <li class="fragment">one free end can latch to a hold in wall</li>
            <li class="fragment">controlled via joint angles</li>
            <li class="fragment">N line segments gives N "R" joints (including latch)</li>
            </ul>
            <img class="fragment" width="800px" src="media/images/4R.png">
          </section>
          <section>
            Other chains
            <img src="media/images/chains.png">
          </section>
          <!-- <section> -->
          <!--   <h2>tree agent</h2> -->
          <!--   <ul> -->
          <!--   <li class="fragment">chain agents in a tree structure</li> -->
          <!--   <li class="fragment">one free end of a chain agent can latch to a hold in wall</li> -->
          <!--   <li class="fragment">controlled via joint angles, but has hierarchical control</li> -->
          <!--   </ul> -->
          <!--   <img class="fragment" width="800px" src="media/images/2x2R.png"> -->
          <!-- </section> -->
          <!-- <section> -->
          <!--   3 x 2R can be in two configurations, note the coincident controls and multiple free ends -->
          <!--   <img src="media/images/3x2R.png"> -->
          <!-- </section> -->
          <!-- <section> -->
          <!-- <table> -->
          <!--   <tbody> -->
          <!--     <tr> -->
          <!--       <th style="padding: 0">4R (chain)</th> -->
          <!--       <th style="padding: 0">2 x 2R (tree)</th> -->
          <!--     </tr> -->
          <!--     <tr class="fragment"> -->
          <!--       <th style="padding: 0"><img width="400px" src="media/images/4R.png"/></th> -->
          <!--       <th style="padding: 0"><img width="400px" src="media/images/2x2R.png"/></th> -->
          <!--     </tr> -->
          <!--     <tr class="fragment"> -->
          <!--       <td ><span style="font-size: 0.4em">both translation and rotation is transferred down the chain</span></td> -->
          <!--       <td ><span style="font-size: 0.4em">hierarchical control, only translation is transferred down the tree</span></td> -->
          <!--     </tr> -->
          <!--     <tr class="fragment"> -->
          <!--       <th style="padding: 0"><img width="300px" src="media/images/4R-rot.png"/></th> -->
          <!--       <th style="padding: 0"><img width="300px" src="media/images/2x2R-rot.png"/></th> -->
          <!--     </tr> -->
          <!--   </tbody> -->
          <!-- </table> -->
          <!-- </section> -->
          <section>
            <h2>the task</h2>
            <ul>
            <li class="fragment">To plan the motion of an agent in realtime, so that it reaches the finish hold following the world rules</li>
            <li class="fragment">To make the motion natural (human/animal-like) using simple heuristics</li>
            </ul>
          </section>
        </section>

        <section>
            <h2>the motivation</h2>
            <ul>
            <li class="fragment">In games, this can be used to improve climbing character animation</li>
            <li class="fragment">As robots, they can climb difficult and challenging terrain for reconnaissance and rescue missions</li>
            <li class="fragment">Can generate new climbing routes and detect dangerous ones</li>
            <li class="fragment">Super fun to watch agents/robots climb walls</li>
            </ul>
        </section>

        <section>
            <section>
            <h2>related work</h2>
            </section>
            <section>
              Lot of recent progress in character animation for walking, running, jumping, dribling, swimming

              TODO: add gifs and cite
            </section>
            <section>
              Not a lot explicity in climbing

              TODO: add gifs and cite
            </section>
        </section>

        <section>
            <h2>approach</h2>
        </section>

        <section>
            <section>
            <h2>PRM/A* + IK</h2>
            <ul>
            <li class="fragment">Split the task</li>
            <li class="fragment">Plan in holds space using Probabilistic Roadmap and A*(or D*-Lite) search</li>
            <li class="fragment">Move from hold to hold using Inverse Kinematics</li>
            </ul>
            </section>
            <section>
            <h3>simplest case - 2R chain - IK</h3>
            <img class="fragment" width="200px" src="media/images/2R-ana.png" />
            <ul>
            <li class="fragment">Free end spans a concentric donut with inner and outer radii $| l_1 - l_2 |$ and $l_1 + l_2$</li>
            <li class="fragment">Given goal point is in the span</li>
            </ul>
            <img class="fragment" width="300px" src="media/images/2R-ana-e1.png" />
            <img class="fragment" width="250px" src="media/images/2R-ana-e2.png" />
            <img class="fragment" width="250px" src="media/images/2R-ana-e3.png" />
            <ul>
            <li class="fragment">$ l = 0 \rightarrow l_1 = l_2 \& (x, y) = (0, 0) \rightarrow \theta_2 = 180^\circ $</li>
            </section>
            <section>
            <h3>simplest case - 2R chain - IK</h3>
            <li class="fragment">Analytical solve for goal joint angles given a goal point in the span</li>
            <li class="fragment">Linearly interpolate from current joint angles to goal joint angles</li>
            <li class="fragment">Switch pivot once reached</li>
            </ul>
            </section>
            <section>
            <h2>Switching pivot - implementation detail</h2>
            <ul>
            <li class="fragment">When switching pivot joint angles have to be reassigned, since this is new IK problem</li>
            </ul>
            <ol class="fragment">
              <li>Pivot position is the previous free end position</li>
              <li>Order of lengths of links are reversed</li>
              <li>From the dynamics $q_{new} = [\sum_{i=1}^{n} q_i - \pi, -q_{n-1}, ..., -q_{1}]$</li>
            </ol>
            </section>
            <section>
            <h3>simplest case - 2R chain - PRM</h3>
            <ul>
            <li class="fragment">PRM edge lens can be clamped b/w $| l_1 - l_2 |$ and $l_1 + l_2$ to ensure reachability of free end</li>
            </ul>
            </section>
            <section>
            <h3>simplest case - 2R chain - demo</h3>
            <p>BG: joint angle space, Red: goal, Blue: current</p>
            <video width="500px" controls src="media/videos/2R-ANA.mp4"></video>
            </section>
            <section>
            <h3>simplest case - 2R chain - tradeoffs</h3>
            <ul>
              <li class="fragment">With proper PRM edge lens, PRM path existence guarantees reachability</li>
              <li class="fragment">One IK solve per hold in the PRM generated path</li>
            </ul>
            </section>
            <section>
            <h3>nR chain - IK</h3>
            <ul>
            <li class="fragment">Too many degrees of freedom, therefore no general analytical solution</li>
            <li class="fragment">Employ iterative solutions</li>
            </ul>
            </section>
            <section>
            <h3>nR chain - IK - Jacobian Transpose</h3>
            <li class="fragment">Given goal point is in the span</li>
            <img class="fragment" width="300px" src="media/images/nR-JT1.png" />
            <img class="fragment" width="250px" src="media/images/nR-JT2.png" />
            <img class="fragment" width="250px" src="media/images/nR-JT3.png" />
            <li class="fragment">simple, fast, looks natural, decently numerically stable</li>
            <li class="fragment">might take long time to converge depending on gradient magnitude</li>
            </section>
            <section>
            <h3>Ex. 4R chain - Jacobian Transpose</h3>
            <video width="500px" controls src="media/videos/4R-JT.mp4"></video>
            </section>
            <section>
            <h3>nR chain - IK - Pseudo Inverse</h3>
            <li class="fragment">Given goal point is in the span</li>
            <img class="fragment" width="300px" src="media/images/nR-PI1.png" />
            <img class="fragment" width="250px" src="media/images/nR-PI2.png" />
            <li class="fragment">produces shorted free end path</li>
            <li class="fragment">contains matrix inversion, so can be numerically unstable</li>
            </section>
            <section>
              <h3>Ex. 4R chain - Pseudo Inverse</h3>
            <video width="500px" controls src="media/videos/4R-PSI.mp4"></video>
            </section>
            <section>
            <h3>nR chain - tradeoffs</h3>
            <ul>
              <li class="fragment">With proper PRM edge lens, PRM path existence guarantees reachability</li>
              <li class="fragment">One IK gradient step per tick</li>
              <li class="fragment">Multiple solutions exist, no control over what we are convering onto</li>
            </ul>
            </section>
            <section>
              <h3>nR chain - n >> 1 - can simulate worms</h3>
            <video width="500px" controls src="media/videos/nR-worm.mp4"></video>
            </section>
        </section>

        <section>
            <section>
            <h2>Climb cycle</h2>
            <ul>
              <li class="fragment">A cyclic state machine to animate climbing motion</li>
            </ul>
            </section>
            <section>
            <h2>Two arm</h2>
            <ul>
              <li class="fragment">Two arms modeled using 2 nR chains</li>
              <li class="fragment">Independent motion but connected at neck</li>
            </ul>
            <img class="fragment" width="400px" src="media/videos/2arm.jpg"/>
            </section>
            <section>
            <h2>Two arm - Climb cycle</h2>
            <ol>
              <li class="fragment"> Move a random arm to the next milestone </li>
              <li class="fragment"> Move neck below the latest moved arm </li>
              <li class="fragment"> Move the other arm </li>
              <li class="fragment"> Go to step 1 </li>
            </ol>
            </section>
            <section>
            <h2>Two arm - Climb cycle</h2>
            <video width="500px" controls src="media/videos/2arm.mkv"></video>
            </section>
            <section>
            <h2>Four arm</h2>
            <ul>
              <li class="fragment">Four arms modeled using 4 nR chains</li>
              <li class="fragment">Independent motion but connected at neck and tail, neck to tail line segment is always vertical</li>
            </ul>
            <img class="fragment" width="400px" src="media/videos/4arm.jpg"/>
            </section>
            <section>
            <h2>Four arm - Climb cycle</h2>
            <ol>
              <li class="fragment">Move a random arm to the next milestone</li>
              <li class="fragment">Move neck and tail below the latest moved arm simultaneously</li>
              <li class="fragment">Move the opposite leg to a certain tuned displacement from tail</li>
              <li class="fragment">Move the other arm next milestone</li>
              <li class="fragment">Move neck and tail below the latest moved arm simultaneously</li>
              <li class="fragment">Move the opposite leg to a certain tuned displacement from tail</li>
              <li class="fragment">Go to step 1</li>
            </ol>
            </section>
            <section>
            <h2>Four arm - Climb cycle</h2>
            <video width="500px" controls src="media/videos/4arm.mp4"></video>
            </section>
            <section>
            <h2>Four arm - Race</h2>
            <video width="500px" controls src="media/videos/race.mkv"></video>
            </section>
            <section>
            <h2>With bells and whistles</h2>
            <video width="500px" controls src="media/videos/wild.mp4"></video>
            </section>
        </section>

        <section>
            <section>
            <h2>Planning hierarchy - Until now</h2>
            <ol>
              <li class="fragment">Hold space planning using PRM/A*</li>
              <li class="fragment">Orchestrating arms using climb cycle</li>
              <li class="fragment">Hold to hold using analytical/iterative IK</li>
            </ol>
            </section>
            <section>
            <h2>Computational bottlenecks - Until now</h2>
            <ul>
              <li class="fragment">IK gradient descent step - matrix multiplications or inverses</li>
            </ul>
            </section>
            <section>
            <h2>Pros - Until now</h2>
            <ol>
              <li class="fragment">Reasonable reachability guarantees for chain agents</li>
              <li class="fragment">Reachability guarantees are only as good as the climb cycle</li>
              <li class="fragment">Pretty good motion</li>
            </ol>
            </section>
            <section>
            <h2>Cons - Until now</h2>
            <ul>
              <li class="fragment">No control over descent i.e. pose attained</li>
              <li class="fragment"><img width="400px" src="media/images/badpose.png"/></li>
              <li class="fragment">No multi limb coordination</li>
              <li class="fragment">No considerations of gravity</li>
              <li class="fragment">No variance in generated motion during IK phase</li>
            </ul>
            </section>
            <section>
            <h2>Fixes</h2>
            <ul>
              <li class="fragment">To prevent unwanted poses the joint angle domain can be restricted. Previously $(-\infty, \infty)$, now something like $[-30^\circ, 60^\circ]$</li>
              <li class="fragment">To enable multi limb coordination instead of modelling two arms as independent nR chains, model it as single 2nR chain</li>
              <li class="fragment">To add the effect of gravity, add center of mass terms into gradient descent</li>
            </ul>
            </section>
        </section>

        <section>
          <section>
          <h2>Switching pivot with angle constraints - GORY IMPL detail</h2>
          <ul>
          <li class="fragment">In addition to previous steps for switching pivot we also need to reassigned joint angle clamps</li>
          <li class="fragment">Due to sigma term in angle reassignment, first and last angles cannot be clamped</li>
          </ul>
          </section>
          <section>
          <h2>2 arm as 4R</h2>
          <img width="800px" src="media/images/3.0.intro.gif"/>
          </section>
          <section>
          <h2>Gravity</h2>
          <ul>
            <li class="fragment">Adding gravity term to the loss function for gradient descent</li>
            <li class="fragment"><img width="500px" src="media/images/gra1.png"/></li>
            <li class="fragment"><img width="400px" src="media/images/gra2.png"/> <img width="400px" src="media/images/gra3.png"/></li>
            <li class="fragment"><img width="200px" src="media/images/gra4.png"/></li>
            <li class="fragment">Everything is expressed in terms of joint angles</li>
          </ul>
          </section>
          <section>
          <h2>Gravity - impl detail</h2>
          <ul>
            <li class="fragment">As is the time complexity of calculating these terms is $O(N^3)$</li>
            <li class="fragment">But using substructres (dynamic programming) we can bring it down to $O(N^2)$</li>
          </ul>
          </section>
          <section>
          <h2>with and without gravity</h2>
          <img width="1600px" src="media/images/3.1.com.gif"/>
          </section>
        </section>

        <section>
          <section>
          <h2>New problems</h2>
          <ul>
            <li class="fragment">Constraints + Gradient descent = local minima</li>
            <li class="fragment">Can be mitigated but still a core problem</li>
          </ul>
          <img class="fragment" width="800px" src="media/images/4.0.local_minima.gif"/>
          </section>
          <section>
          <h2>Montecarlo methods - Arbitrarly close global IK solves</h2>
          <ul>
            <li class="fragment">To prevent bad local minima we need general global IK solves</li>
            <li class="fragment">But there are none for n > 2!</li>
            <li class="fragment">So comprimise. Go for approximate global solves</li>
          </ul>
          </section>
          <section>
          <h2>No prior random sample solve</h2>
          <ul>
            <li class="fragment">Given a goal free end position, sample many joint angle tuples within clamps</li>
            <li class="fragment">Compute the loss function for each tuple</li>
            <li class="fragment">Keep track of tuple that gives closest to goal</li>
            <li class="fragment">Can be made arbitrarily close to global optimum</li>
            <li class="fragment">Parallelizable</li>
          </ul>
          </section>
          <section>
          <h2>No prior random sample solve</h2>
          <img width="400px" src="media/images/4.0.local_minima.gif"/>
          <img width="400px" src="media/images/4.1.solve_local_minima.gif"/>
          </section>
          <section>
          <h2>Current state random sample solve</h2>
          <ul>
            <li class="fragment">Similar to no prior random sample solve</li>
            <li class="fragment">Instead of uniformly sampling the tuple in the clamps space, start from current joint angle space</li>
            <li class="fragment">Sample around the current state, keep track of best tuple, and repeat from there</li>
            <li class="fragment">More prone to local minima than former, but faster</li>
            <li class="fragment">Can be made arbitrarily close to global optimum</li>
            <li class="fragment">Parallelizable</li>
          </ul>
          </section>
          <section>
          <h2>Integration with gradient descent</h2>
          <ul>
            <li class="fragment">Since monte carlo methods bring approximately close to goal, use gradient descent from there to snap to goal</li>
            <li class="fragment">In practice</li>
          </ul>
          <img class="fragment" width="800px" src="media/images/snapping.png"/>
          </section>
          <section>
          <h2>Perks</h2>
          <ul>
            <li class="fragment">Due to impl detail, clamps could not be enfored on first and last angles</li>
            <li class="fragment">But with monte carlo methods we can enforce (pseudo) clamps while sampling</li>
          </ul>
          <img class="fragment" width="400px" src="media/images/5.0.wrong_side.gif"/>
          <img class="fragment" width="400px" src="media/images/5.1.solve_wrong_side.gif"/>
          </section>
          <section>
          <h2>Perks</h2>
          <ul>
            <li class="fragment">Due to nature of monte carlo solves the generated motion has variance even during IK phase</li>
          </ul>
          <img class="fragment" width="800px" src="media/images/6.4.out.gif"/>
          </section>
          <section>
          <h2>Matching hands</h2>
          <ul>
            <li>Always switching pivots won't work</li>
          </ul>
          <img width="800px" src="media/images/7.2.switching_failure.gif"/>
          </section>
          <section>
          <h2>Matching hands</h2>
          <ul>
            <li class="fragment">Simple climbers solution, match hands</li>
            <li class="fragment">If agent is reaching with left hand but goal on on right of pivot (or) If agent is reaching with right hand but goal on on left of pivot</li>
          </ul>
          <img class="fragment" width="600px" src="media/images/7.3.matching.gif"/>
          </section>
        </section>

        <section>
            <section>
            <h2>Summary and roadmap and impact</h2>
            </section>
            <section>
            <h2>Future work</h2>
            Scaling / composing for general tree agent
            </section>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/math/math.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        math: {
          mathjax: 'https://cdn.jsdelivr.net/gh/mathjax/mathjax@2.7.8/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          // pass other options into `MathJax.Hub.Config()`
          TeX: { Macros: { RR: "{\\bf R}" } }
        },
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath ]
      });
    </script>
  </body>
</html>
